# Android 面试大全
Android面试相关的总结
包含两部分  
## Android 部分 

### Android基础部分 
1. Handler原理
2. 
### Android源码分析部分 

## Java部分 
### 基础面试题 
1. Java程序运行机制
2. hashmap和hashtable区别  HashMap源码分析  HashMap底层结构 HashMap查找效率
3. 设计一个线程安全的HashMap
4. 为什么产生死锁
5. jvm类加载
6. java反射获取私有属性，改变值 反射用途
7. synchronized关键字的用法
8. ArrayList的底层实现
9. 死锁： 是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态

HashMap 的实现过程 HashMap 的实现原理

volatile 的作用，为什么会出现变量读取不一致的情况， synchronized 的区别

Tcp 三次握手过程

Java 中内部类为什么可以访问外部类

浏览器输入地址到返回结果发生了什么

Tcp 是如何保证可靠性传输的

如何设计在 UDP 上层保证 UDP 的可靠性传输

Java内存模块分区和GC机制，GC算法有哪些

### 多线程部分 

多核里面进程和线程的表现

线程如何实现

### 工程

APK 包含了哪些东西，打包过程是什么；

断点上传如何设计

Android 音频控件如何使用，底层原理

ArrayList 如何删除重复的元素或者指定的元素


设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？（二叉排序树，建立索引）

手写单例模式

## 算法部分
### 排序算法
1. 冒泡排序
2. 快速排序 

外排序有哪些，与内部排序的区别

算法：单链表输出倒数第 k 个元素，冒泡排

100 万个数据找出 100 个最大的 
小顶堆

数组插入

单链表，O（1）复杂度内删除一个结点，写算法

冒泡排序的链表实现

手写堆排序

连续子序列问题，保证 i < j, Ai < Aj 的算法思想

最短路径的算法思想

饿汉式单例和懒汉式单例的区别

一个 Activity 绑定 Service 后，在 startService ，然后在 stopService，此时 Service 是否还需要解绑

Webview优化
Webview优化

Binder的大体设计模式

字符串中查找子字符串一般用什么算法

密码学中两大加密算法是什么

排序中哪个算法复杂度为o(n)

图片压缩不失真的情况下能压缩多少倍？Android中线程能开多少个？

Handler为什么会发生内存泄漏

## 面试案例

阿里巴巴面试案例 https://maimai.cn/article/detail?fid=1160837648&efid=Pu_Xg-tnob2owjriFS-ehg

## 面试题

#一、图片

### 图片库的对比

图片库名称|实现原理|优点|缺点
-|-|-|-
Fresco||1.最大的优势便在于5.0以下(最低2.3) bitmap的加载，在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem)，而且图片不显示时，占用的内存会自动被释放，这会使APP更加流畅，减少因图片内存占用而引发的OOM。5.0以后的系统默认存储在Ashmem区了2.支持加载Git动态图和Webp格式的图片3.图片的渐进式呈现，图片先呈现大致的轮廓，然后随着图片下载的继续，逐渐成仙清晰的图片，这对于慢网络对说，用户体验更好。|框架体积比较大，3M左右，会增加APK的大小
Glide||1.图片默认格式为RGB565，而不是ARGB888，内存开销更小2.图片缓存的尺寸是和ImageView一样的，这使得图片加载更快3.支持加载Git动态图4.支持配置网络请求5.Glide的with()方法可以接收activity和fragment，图片的加载会和Activity和Fragment的生命周期保持一致|Glide 显示动画会消耗很多内存
Picasso||1.图片质量高，但加载速度一般2.Picasso体积比起Glide小|只缓存一个全尺寸的图片

具体的可以参考这篇博客[Android的Glide库加载图片的用法及其与Picasso的对比](http://www.jb51.net/article/83152.htm)，虽然有点老了，新版本的api有许多变动，但是还是有参考价值的。（**以后有时间我把最新的Glide 4.+ 和 Picasso最新版  Fresco 做一个对比，写一篇博客介绍一下**）

### 图片库的源码分析

这个网上有很多博客，自己可以去看看，内容太多，不方便在这里写出来了。

### 自己去实现图片库，怎么做？

这里介绍一下思路，详细的可以看我给出的一个示例sample，自己手写的一个类似于Picasso的图片框架

**需要注意的几点：**

* 1.首先要做好缓存，这是必备的：可以使用三级缓存，Android提供了LruCache：硬盘缓存用DiskLruCache，内存缓存用LRUCache。
* 2.图片加载需要压缩，可以考虑BitmapFactory做压缩
* 3.图片加载的来源，是从文件，还是网络
* 4.图片的异步加载和同步加载
* 
* 知识点内存缓存 

* 图片下载时请求转发


#四、算法

### 排序算法有哪些？

常用的10大排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。

### 最快的排序算法是哪个？
### 手写一个冒泡排序

见代码：

### 手写快速排序代码

见代码：

### 快速排序的过程、时间复杂度、空间复杂度
### 手写堆排序

见代码：

### 堆排序过程、时间复杂度及空间复杂度
### 写出你所知道的排序算法及时空复杂度，稳定性

一张图清楚地说明这些算法之间的对比：

![](https://github.com/AweiLoveAndroid/CommonDevKnowledge/blob/master/pic/Sorting-algorithm.png?raw=true)


相关术语：
稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内排序（In-place）：所有排序操作都在内存中完成；
外排序（Out-place）：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
时间复杂度： 一个算法执行所耗费的时间。
空间复杂度：运行完一个程序所需内存的大小

具体讲解可以参考博客：[https://www.cnblogs.com/onepixel/articles/7674659.html](https://www.cnblogs.com/onepixel/articles/7674659.html)

### 二叉树给出根节点和目标节点，找出从根节点到目标节点的路径
### 给阿里2万多名员工按年龄排序应该选择哪个算法？
### GC算法(各种算法的优缺点以及应用场景)
### 蚁群算法与蒙特卡洛算法
### 子串包含问题(KMP 算法)写代码实现
### 一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法
### 万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)
### 百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。
### 两个不重复的数组集合中，求共同的元素。
### 两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？
### 一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法
### 一张Bitmap所占内存以及内存占用的计算
### 2000万个整数，找出第五十大的数字？
### 烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？
### 求1000以内的水仙花数以及40亿以内的水仙花数
### 5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同
### 时针走一圈，时针分针重合几次
### N*N的方格纸,里面有多少个正方形
### x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？

> 什么是ANR 如何避免它？

在Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应
用程序无响应（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR 给用户。
不同的组件发生ANR 的时间不一样，主线程（Activity、Service）是 5 秒，BroadCastReceiver 是 10 秒。

**解决方案：**
将所有耗时操作，比如访问网络，Socket 通信，查询大量SQL 语句，复杂逻辑计算等都放在子线程中去，然后通过handler.sendMessage、runonUITread、AsyncTask 等方式更新UI。无论如何都要确保用户界面操作的流畅度。
如果耗时操作需要让用户等待，那么可以在界面上显示进度条。


> synchronized 和volatile 关键字的区别？

synchronized 和volatile的作用：
1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
区别：
1）volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的
2）volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性
3）volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
4）volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化