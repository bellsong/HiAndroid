## Android内存优化常规思路

### 背景
App开发中随着业务迭代，功能的增加，内存逐步上涨，为了保证平稳运行，减少内存占用过多衍生的卡顿、响应慢等用户体验问题，甚至内存溢出、ANR等稳定性问题
本文就内存优化实践过程，总结一下常规的优化手段。
                           
### 优化思路
1. 了解现状通过当前压测结果，切入业务进行了解，借助工具分析内存占用情况（MAT或Memory Profiler）注意，一定要运用数据来说明现状问题，后续也通过数据来验证优化效果。
常见内存占用多的情况：内存泄漏、图片（本地和网络）、非常驻业务的对象缓存、WebView

2. 制定方案针
对Launcher承载的业务和内存情况，分别进行内存泄漏排查、本地图片优化、业务解耦及时回收不使用的内存对象，WebView处理等

3. 逐步执行见下面【内存优化手段】

4. 分步验证

每完成一个优化项，进行压测，通过数据对比优化效果。

5. 重复1-4直到达到目标

### 内存优化手段

1. 内存泄漏排查
常规的内存泄漏情况
a.生命周期长的对象一直持有生命周期已经结束的对象，导致一直无法释放，例如单例中传了Activity
b.handler内存泄漏（可以通过声明为静态,软引用方式引入Activity）
c.匿名内部类会引用外部类
d.WebView

2. 本地图片优化

1）利用TinyPng，通过合并图片中相似的颜色，通过将 24 位的 PNG 图片压缩成小得多的 8 位色值的图片，并且去掉了图片中不必要的 metadata（元数据，从 Photoshop 等工具中导出的图片都会带有此类信息），这种方式几乎能完美支持原图片的透明度。将App图片进行一轮优化。

影响点：保证图片在肉眼察觉不出的效果变化前提，减少图片加载时的内存。同时apk Size也能减少。

2）Bitmap处理
展示高分辨率图片的时候，最好先将图片进行压缩。压缩后的图片大小应该和用来展示它的控件大小相近，在一个很小的ImageView上显示一张超大的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存，而且在性能上还可能会带来负面影响Bitmap是内存消耗的大头，当使用时要及时回收。
另外配置：inSampleSize：缩放比例，图片按需加载，避免不必要的大图载入。decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。

3）纯色图处理技巧：
例如背景图，用代码颜色填充。

3. 网络图片优化方案
基于我们图片加载框架Glide，对于无限制下发的图片进行尺寸限制处理。
影响点：保证图片加载内存不受图片尺寸不规范导致内存增多。

4. 业务模块解耦方案
业务解耦，拆分进程（例如Webview的）

### 内存优化工具

1. LeakCanary
查看内存泄漏情况，详见https://github.com/square/leakcanary

2. AndroidStudio自带的 Android Profiler
比较直观的看到App的内存变化情况，并且能方便的dump操作，查看对象占用内存。MAT内存分析工具，快速查看内存中对象的占用大小，通过GC Root 链能看到哪些对象引用阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象

### 注意点
前后压测条件一致
保证验证工具一致

WebView内存问题
webview占用内存比较多，并且存在内存泄漏情况，使用时要多加留意，一般不直接在xml里面声明，直接通过代码创建对象，退出时候及时销毁，甚至可以考虑将webview相关的activity单独进程。

### 小结和后续

结合业务，通过常规的手段对内存进行优化，遵循”用完就放“的原则，优化过程通过数据验证效果。除了代码层面上注意，可考虑建立一套健全的性能监控体系，通过数据及时发现相关的性能问题。


二 从代码角度优化内存
一些android的特性，java classes ，以及代码结构有时候会占用更多内存，我们应该通过选择更高效的方案来减少内存的使用。

节省的使用Service
在后台保留一个不需要的service，是最糟糕的内存管理方式之一。如果你需要通过service在后台去执行任务，除非当它将要去执行一个任务的时候，否则不应该一直在后台驻留。在完成任务后记得将service停掉，否则可能在不经意间导致了内存泄露（这里应该是指service占用了无用的资源）。

当你启动一个service的时候，系统会更好的保留service所运行的进程。这样会导致service 进程非常的消耗资源，因为被一个service占用的RAM部分，其它Servie就不可用了。这样会减少系统在LRU cache中缓存的进程数量，降低了app的切换效率。当内存紧张时，甚至会导致内存抖动，并且系统无法维护足够的进程来托管当前运行的所有服务。。

尽量避免使用持久化的service，因为它持有占有了可用内存。建议使用其它替代方案，比如 JobScheduler。关于JobScheduler如何调度后台进程，可以参考Background Optimizations。

如果必须使用service，最好是使用 IntentService来限制service的生命周期，一旦处理完启动它的Intent，该IntentService就会将自己停掉。更多信息可以参考Running in a Background Service.

使用内存更高效的代码结构
一些编程语言中的类没有针对移动设备进行优化。比如，通用HashMap实现可能是相当的内存低效，因为它需要为每个映射关系创建单独的对象。

Android框架中提供了几种优化过的数据结构，比如SparseArray, SparseBooleanArray 和 LongSparseArray,比如SparseArray 避免了对key的自动装箱（导致每个实体会多创建对象），所以更高效。

小心的使用代码抽象
开发人员经常简单地使用抽象作为一个好的编程实践，因为抽象可以提高代码的灵活性和维护性。但是抽象会带来严重的开销：通常它们需要额外执行相当多的更多代码，需要更多的时间和RAM将代码映射到内存中。因此，如果你的抽象不能带来比较大的好处，那么请避免使用抽象。

比如，枚举相对于静态通常需要两倍甚至更多的内存。你应该严格避免在android中使用枚举。

使用nano protobufs进行序列化
Protocol buffers是由Google研发，跨语言、跨平台，扩展性非常好的序列化数据结构，类似XML，但是更小更快，更简单。如果你决定使用protobufs进行序列化，你应该在客户端代码中使用nano protobufs。因为一般的protobufs会生成冗余的代码，导致各种问题，比如增加RAM的使用，APK大小，比较低的执行效率。

更多信息可以参考 protobuf readme “Nano version”部分

避免内存抖动
上面提到，通常垃圾回收事件不会影响到你的app性能。但是，在短时间内突然发生很多的垃圾回收事件就会占用了帧的时间。系统花费在垃圾回收上的时间越多，那么用于渲染或者音频的时间就越少。

通常，内存抖动会导致大量的垃圾收集事件发生。在实践中，内存抖动是指在在一个特定时间内分配了很多临时对象。

比如，你可能在for 循环中分配了多个临时对象。或者在onDraw中创建了新的Paint或者Bitmap对象。这两种情况下，app都会快速创建大量的对象。这样会快速消耗掉young generation中的可用内存，强制垃圾回收器触发回收事件。

通过 Analyze your RAM usage 可以帮你找到代码中哪些地方导致了内存抖动。

一旦定位到了问题，就应该试着在性能问题严重的地方减少对象的分配。考虑将他们移到内部循环外面，可能的话，也可以通过 Factory模式来实现。

三 移除内存敏感的资源和库
一些资源和库会在你不知道的情况下占用掉很多内存。总览下apk的大小，包含了哪些可能导致内存浪费的第三方的库和内嵌资源。通过移除冗余的。不必要的资源和库来提高内存的使用。

减小总体的APK大小
您可以通过减少应用程序的整体大小来显着降低应用程序的内存使用量。Bitmap 大小、资源、动画帧数，和第三方库都可能增大了APK的大小。Android Studio 和 Android SDK 提供了一些工具可以帮你减少资源和外部依赖。

如何如何减少APK的大小，可以参考Reduce APK Size.

小心的使用注解框架
比如Guice或者RoboGuice的依赖注解框架虽然简化了你的代码书写，并为测试或者其它的可能变化配置信息提供了适配。但是这些依赖框架并没有针对移动设备做优化。

比如，这些框架通常会通过扫描你的代码或者注解来进行初始化。系统会将这些映射页面分配到内存中，以便Android可以删除它们; 但这些映射页面所占用的内存会在很长一段时间之后才会被删除。

如果你需要使用注解框架，考虑使用Dagger。比如，Dagger不会使用反射扫描代码。Dagger的严格实现意味着它可以用于Android应用中而不会增加不必要的内存使用。

小心的使用外部库
外部库的代码通常不会为移动环境而写，执行在移动设备上也更低效。当你决定使用一个外部库的时候，可能需要为移动设备做优化。在你决定使用之前，先考虑代码量的大小和RAM占用空间。

有时一些针对移动设备优化的库由于不同的实现也会产生问题。比如，某个库可能使用了nano版本的protobufs，然而另一个使用了micro protobufs，就会导致两个版本的实现。这样就会导致两份

logging，analytics，Image loading框架、缓存以及其它一些不期望的问题。

尽管 ProGuard 会帮助你移除API和资源，但是不会移除一个库的内部依赖。如果你使用了依赖库中的Activity子类（会导致比较宽泛的依赖关系，和你现有的Activity就会有很大冲突），问题将尤为严重。又或者，如果这个库中使用了反射等技术，你还要花大量时间去处理混淆。所以在你决定使用一个库的时候，需要慎重的考虑它是否非常匹配你的需求，否则你应该考虑自己实现一套。

三 Further Optimizing Your App
为低内存设备或者在低内存条件做优化，可以提升系能和用户体验。移除对后台的service的依赖和静态方式注册的隐式广播，可以帮助你的app在这样的设备上运行的更好。尽管7.0上采取了一些措施减少了这些问题，但还是建议去优化app，即使在完全没有使用后台进程的情况也可以正常运行。

Android 7.0 (API level 24)引入了一些 Android Debug Bridge (ADB) 命令，可以帮助你测试app在禁止后台进程的情况下app的行为：

模拟隐式广播和后台service不可用的情况，可以使用下面的命令

$ adb shell cmd appops set RUN_IN_BACKGROUND ignore

重新开启隐式广播和后台service

$ adb shell cmd appops set RUN_IN_BACKGROUND allow