编码注意事项
     
       为了更好地提高项目的编码质量，提升程序的性能，大家可以关注一下以下的这些注意事项，

一、Java相关
1.类中尽量少用全局的static成员变量，它会一直占用内存空间，浪费内存。

2.尽量少用单例模式，除非需要管理和共享的数据涉及到程序全局的，如全局
的监听器、缓存。

3.当要用到字符串连接的情况时，尽量使用StringBuilder来进行处理，避免连接
操作时JVM new一些无用的String对象出来，不仅要花时间生成对象，以后可能
还需花时间对这些对象进行垃圾回收和处理。同时也可以直接指定stringBuilder
的容量，避免在容量不够的时候自动增长，以提高程序性能。


4.在使用完I/O流、cursor、数据库等的时候应该及时关闭，避免内存泄露。
（一般是在try/catch块中的finally里面进行关闭）

5.尽量减少对变量的重复计算、函数的重复调用
如for循环
 
6.慎用异常，抛出异常首先要创建一个新的对象。Throwable接口的构造函数
调用名为fillInStackTrace()的本地（Native）方法，fillInStackTrace()方法检查
堆栈，收集调用跟踪信息。只要有异常被抛出，VM就必须调整调用堆栈，因
为在处理过程中创建了一个新的对象。
 
 
7.可用移位来代替乘除法，提高程序性能。


8.涉及到多线程同步场景时，使用AtomicInteger来进行计数（里面提供了原子性的int类型增减操作）。
 
 
9.避免static final来定义没有被外部调用的常量，只需定义final即可。

 
10.当我们对序列化进行控制时，可能某个特定子对象不想让Java序列化机制自动保存与恢复。如果子对象表示的
     是我们不希望将其序列化的敏感信息（如密码），通常会面临这种情况。即使对象中的这些信息是private属性，
     一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问到它。
     这个时候，就可以使用transient关键字逐个字段地关闭序列化，transient关键字只能和Serializable对象一起使用。

二、Android相关
1.项目中注册的listener和receiver的，在注册后，需要在页面销毁或者不需要使用的时候把他们给注销掉，避免造成不必要的内存占用和引起一些不可预知的bug。
 
2.耗时的操作尽量都在子线程中进行处理，如文件操作、网络相关操作、Html.fromHtml、数据加密等

3.在程序设计时，可以创建一个manager类来管理共享数据。
 
 
4.使用完bitmap等占用内存比较大的对象时需要及时的释放。
（如在fragment或activity中保存了一个bitmap的引用，在onDestroy（）的时候就需要释放掉）


5.在adapter中，尽量使用自定义viewholder来保存convertview中view的引用，避免多次findviewbyid操作。
 
 
6.项目中，当需要使用到线程的时候，尽量使用线程池。
 
7.使用viewstub进行动态加载，避免在布局中将view先设置为gone再设置为visible。
 
 
8.在使用context时，尽量使用application的context，以免context引用一直无法释放。
 
 
9.尽量避免使用setImageBitmap、setImageResource，因为它们都是通过java层的createBitmap来完成的，需要消耗更多内存，
   改用先通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的 source。


10.常用SpannableString，里面提供了许多text相关的效果处理，避免创建一些无谓的view来浪费资源。

三、设计模式相关
1.单例模式
    完整范例：

     a.在写单例模式的时候，必须定义一个私有的构造方法。
 
     b.定义静态的类实例变量的时候，必须加上volatile关键字。
 
volatile关键字：
在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。
        volatile关键字就是Java用来保证可见性，当一个共享变量被volatile修饰时，它会保证修改的值
会立即被更新到主存，当有其他线程需要读取时，它会去内存（线程工作内存）中读取新值。
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。
（PS：这里说明一下主存和线程工作内存，Java内存模型规定所有的变量都是存在主存当中；每个
线程都有自己的工作内存，线程中执行的写入操作，首先得在自己的工作线程中对变量i所在的缓存
行进行赋值操作，然后再写入主存当中）
相关链接：http://www.cnblogs.com/dolphin0520/p/3920373.html
        
 
 
 
